\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{mathtools}

\usepackage{pgf,tikz}\usepackage{mathrsfs}\usetikzlibrary{arrows}


\renewcommand{\contentsname}{Contenidos}
\renewcommand{\chaptername}{Capítulo}

\title{Esborrany Treball de Recerca:\\Teoría e implementación de un motor gráfico}
\date{Curso 2017/2018}
\author{Alumno: Joel Pérez\\Profesor: José Ramírez\\Departamento de Matemáticas}


\begin{document}
\lstset{language=C, basicstyle=\ttfamily}
\pagenumbering{gobble}

\maketitle


\newpage

\pagenumbering {arabic}

\begin{abstract}
  En este Treball de Recerca he intentado demostrar cómo funcionan las principales librerías gráficas comerciales y poder entender los diversos cálculos que se efectúan en la ejecución de una aplicación gráfica 3D. Para esto he programado una librería gráfica relativamente simple y la he usado en un motor gráfico que también he programado.
\end{abstract}

\clearpage
\tableofcontents

\newpage
\chapter{Introducción}
\section{Resumen}
Una revolución industrial consiste en la llegada de nuevas máquinas y métodos que permiten optimizar los procesos de producción. La industria del software está pasando actualmente por una de estas revoluciones, dónde están surgiendo multitud de herramientas para agilizar la producción. Estas herramientas oscilan desde librerías para funciones matemáticas simples, pasando por editores de texto inteligentes que van acompañados por un compilador y depurador (\textit{IDE}s) e incluso llegan a motores gráficos comerciales disponibles a cualquier programador con una habilidad intermedia, permitiendo saltar uno de los pasos más laboriosos del proceso de creación de videojuegos.
\\\\
La llegada de esta ola ha sido bastante polémica y ha dividido a las comunidades. Por una parte no se puede negar la importancia de tener herramientas más potentes. Pero por la otra parte hay muchos que piensan que esto ha llevado a la gente a no preocuparse por algunas cuestiones sólo porque lo ven como una cosa del pasado, un problema menor que ya está solucionado por la herramienta que usan. Estos problemas terminan por acumularse y pueden desencadenar en problemas mayores si no se intentan solventar desde la raíz.
\\\\
Mi opinión siempre ha sido la de permanecer escéptico a los programas que pretenden tener un uso generalizado, y siempre he creído que cada herramienta es para una situación concreta, y no se puede intentar usar el mismo método y herramientas para todo.

\newpage
\section{Objetivos}
Según la prioridad asignada he separado los objetivos en dos categorías. Es importante recordar que \textbf{no es un objetivo} obtener un producto de una complejidad y rendimiento similar a librerías y motores gráficos comerciales.
\subsection{Objetivos principales}
\begin{itemize}
\item Investigar la factibilidad de desarrollar una librería gráfica.
\item Estudiar la factibilidad de desarrollar un motor gráfico.
\item Comprender el funcionamiento de un motor gráfico a nivel interno.
\item Crear un motor gráfico agnóstico de plataforma.
\item Familiarizarse con herramientas de expresión científica.
\end{itemize} 
\subsection{Objetivos secundarios}
\begin{itemize}
\item Permitir la compilación tanto de la librería gráfica como del motor en cualquier entorno de desarrollo.
\item Comparar la librería gráfica propia con ejemplos comerciales.
\item Comparar el motor gráfico creado con ejemplos comerciales.
\end{itemize}

\section{Motivación personal}
Existen una gran cantidad de motivaciones personales alrededor de este proyecto. Por una parte soy un gran fanático de la computación y con el Treball de Recerca tengo una buena oportunidad de hacer algo que siempre he deseado hacer. También me he inspirado por un videojuego llamado \textit{Handmade Hero}, el cuál está siendo desarrollado, como hace referencia el nombre, \textit{a mano}, sin hacer uso de librerías modernas. También tengo interés en hacer un programa de un tamaño mayor a lo que estoy acostumbrado y aprender a organizar y a documentar el proceso. Además pretendo aprender a usar diversas herramientas para redactar textos científicos, como el propio lenguaje en el que está escrito este documento, \LaTeX, y el editor de texto Emacs.

\section{Relevancia del estudio en el campo}
Como he comentado previamente, en la actualidad existe una gran polémica con respecto a este tema. Muchas empresas de la indústria de los videojuegos han decidido abandonar la creación de motores para uso específico de sus videojuegos en pro de adoptar motores comerciales generales. Esta decisión ha traído muchos escándalos en los que estos motores de uso generalizado funcionan terriblemente mal en algunas configuraciones concretas y debido a la naturaleza cerrada del motor la desarrolladora del videojuego no ha podido solucionar el problema.
\\\\
Independientemente de la rentabilidad de desarrollar un motor gráfico en la época actual, algo que es indudable es que es completamente necesario entender el funcionamiento del mismo, para poder extraer el máximo rendimiento posible, sea tanto un motor \textit{hecho a mano} como uno comercial.

\section{Límites del trabajo}
Está clara la inviabilidad de desarrollar un motor gráfico a la altura de los ofrecidos acutalmente en el mercado, pues estos han estado desarrollados por un equipo de expertos durante años y tienden a ofrecer una cantidad de rendimiento y funcionalidad que duramente se puede replicar en un proyecto hecho en unos meses por alguien que no tiene ni las nociones académicas ni la experiencia ni los recursos necesarios. Sin embargo esto sólo significa que mi producto no será de uso a la indústria, pero puede tener valor académico.

\section{Metodología empleada para realizar la investigación}
El método del trabajo consiste en la creación de un motor gráfico con una funcionalidad limitada pero suficiente para elaborar una conclusión y reconsiderar la hipótesis. No sólo se intentará hacer un motor gráfico sino que además se busca replicar la funcionalidad de OpenGL en una librería gráfica desarrollada paralelamente al motor gráfico para poder ir un paso más allá. La hipótesis será revisada tanto por el resultado final del proceso de elaboración del motor como por la investigación en el funcionamiento de la industria de los motores gráficos.

\section{Hipótesis}
\textit{Los equipos de desarrollo de software deberían de aspirar a ser ellos mismos quienes crean las herramientas que utilizarán para crear el software en sí. En caso de que esta sea una decisión no rentable, su máxima prioridad debería de ser entender cómo funcionan las herramientas que utilizarán.}
\\\\
Considero que cuando uno forma parte del proceso de creación de software, tiene que tener el mayor conocimiento posible del funcionamiento de aquello que está haciendo. Eso significa psar por pasos que muchas veces se saltan con la finalidad de agilizar el proceso, no obstante no creo que esto sea positivo ya que ha llevado a serioes problemas a la larga.

\newpage

\chapter{Conceptos previos}
\section{Entorno de desarrollo}
En esta sección se comentarán los diversos entornos en los que he trabajado en el Treball de Recerca, tanto desde un punto de vista de desarrrollo de programación como del desarrollo del documento escrito y la presentación oral.
\subsection{Programación}
Dependiendo del sistema operativo en el que se quiera trabajar es necesario tener una preparación concreta.

\subsubsection{Compilación}
Para poder compilar y ejecutar la librería y el motor gráfico son necesarias las herramientas básicas de compilación.
\begin{itemize}
\item{\textbf{make}: necesario para automatizar la compilación}
\item{\textbf{gcc}: programa utilizado como compilador y/o linker}
\item{\textbf{sdl2}: librería utilizada para desarrollo multiplataforma fácilmente, sirve como abstracción para la ventana y comunicación entre el Sistema Operativo y el programa}
\end{itemize}

Posteriormente se puede compilar yendo a la raíz de la carpeta y introduciendo algunos de los siguientes comandos:

\begin{itemize}
\item{\textbf{compilar} la librería gráfica propia y posteriormente compilar el programa}
\begin{lstlisting}[language=bash]
  $ make trgl
\end{lstlisting}
\item{\textbf{compilar} el programa utilizando OpenGL}
\begin{lstlisting}[language=bash]
  $ make opengl
\end{lstlisting}
\item{\textbf{ejecutar} el programa una vez la compilación ha terminado satisfactoriamente}
\begin{lstlisting}[language=bash]
  $ ./bin/program
\end{lstlisting}
\item{\textbf{limpiar} todos los archivos creados durante procesos anteriores de compilación}
\begin{lstlisting}[language=bash]
  $ make clean
\end{lstlisting}
\end{itemize}

\subsubsection{GNU Linux}
GNU Linux es el entorno en el que más cómodo trabajo por diversos motivos. Uno de ellos es lo simple que es encontrar, descargar, instalar y configurar nuevos programas en el sistema, gracias al gestor de paquetes que normalmente viene incluido en la mayoría de distribuciones.
\\\\
Ubuntu es una de las distribuciones más comunes así que explicaré los requisitos previos para la compilación y ejecución del programa en Ubuntu.
\\ Todos los paquetes necesarios se pueden obtener con este comando.
\begin{lstlisting}[language=bash]
  $ sudo apt-get install git libsdl2-dev gcc
\end{lstlisting}
Se puede descargar el Treball de Recerca utilizando el siguiente comando en la carpeta deseada.
\begin{lstlisting}[language=bash]
  $ git clone https://github.com/gorostuck/treball-recerca
\end{lstlisting}

\subsubsection{macOS}
Para compilar macOS es un poco más laborioso debido a que no tiene un gestor de paquetes por defecto.
\\ Lo primero que hay que hacer es ir la página web de SDL y descargar las librerías de desarrollo.
\\ Una vez descargado el fichero .dmg, abrirlo y copiar ``SDL2.framework'' a \textit{/Library/Frameworks}.
\\ Después quizás es necesario volver a firmar el Framework, para hacer esto, hay que abrir una terminal en \textit{/Library/Frameworks/SDL2.framework/} y utilizar el siguiente comando:
\begin{lstlisting}[language=bash]
  $ codesign -f -s - SDL2
\end{lstlisting}
Si las \textit{Command Line Tools} no han sido instaladas previamente, la primera vez que intentemos utilizar el comando \textit{make} nos saltará una ventana preguntando si deseamos instalar las herramientas, para poder compilar el programa será necesario utilizar esas herramientas.



\subsubsection{Microsoft Windows}
TODO: ¿Quiero entrar en profundidad sobre cómo compilar en Windows?

\subsubsection{Code::Blocks}
Aunque no es mi entorno favorito, la verdad es que utilizar Code::Blocks es bastante conveniente y ha sido de utilidad para la depuración. Es tan sencillo como ir a la página y descargar Code::Blocks. Una vez descargado codeblocks, abrir el archivo .cbp dentro de la carpeta del proyecto y todo está listo para compilar y ejecutar. Otra ventaja que tiene es que es multiplataforma con lo que se puede usar en GNU Linux, macOS y en Windows. De hecho se recomienda usar Code::Blocks cuando se trabaje en Windows.

\subsubsection{Control de versión con git y GitHub}
Git es un programa utilizado para controlar un repositorio de código. En concreto, he utilizado el servicio web \textit{GitHub}. Aunque uno de sus principales objetivos es la colaboración entre distintos desarrolladores yo lo he empleado en las siguientes situaciones:
\begin{itemize}
\item{Ser capaz de tener todo el código archivado en un repositorio en internet para poder acceder remotamente y descargarlo.}
\item{Mantener un historial con todos los cambios que se han hecho.}
\item{Tener diversas ramas donde cambian elementos clave y desarrollarlas de forma paralela.}
\item{Visualizar rápidamente los cambios producidos entre diferentes versiones y ramas.}
\end{itemize}
\subsection{Documentación}
\subsubsection{Documento escrito}
Para redactar el documento escrito he utilizado \LaTeX, un lenguaje de programación orientado al procesamiento de texto. Esta herramienta me ha permitido organizar el Treball de Recerca de forma simple y efectiva, además de incluir trozos de código y comandos e incluso expresión matemática.
\subsection{GNU Emacs}
He decidido dar a GNU Emacs su propia subsección debido a que lo he usado constantemente a lo largo de la elaboración de este Treball de Recerca. Lo he usado tanto para programar la librería gráfica y el motor como para documentar todo el proceso. Además también me ha permitido hacer \textit{version control}, compilar e incluso ejecutar el motor gráfico desde el mismo programa. Decidí utilizarlo porque así me permitiría aumentar en gran medida mi rendimiento. Puesto a que es un programa extremadamente complejo, no entraré en gran detalle, pero las principales ventajas que ofrece es la gran modularidad y customizabilidad, por lo que lo he ido adaptando a mis necesidades según he ido avanzando en el proyecto.

\newpage

\chapter{Teoría e implementación de la librería gráfica}
En este capítulo se comentarán todos los aspectos de las funciones creadas en la librería gráfica. Primero desde un punto de vista teórico y después se observará la implementación. Además se comparará con el funcionamiento de una librería gráfica popular, OpenGL.
\section{Nodos y gestión de vértices}
En esta sección comentaré como funciona el sistema de gestión dinámico de vértices y el dibujo de la estructura que forman.
\subsection{Nodo}
Un nodo es una estructura básica multiprósito que además de contener valores contiene punteros hacia otros nodos.
\subsubsection{Nodo en el código}
\begin{lstlisting}[language=C]
  struct Node {
    GLenum Type;          // Tipo de nodo
    GLfloat Real[4];      // Matriz de coordenadas reales
    GLfloat Projected[4]; // Matriz de coordenadas proyectadas
    GLfloat Screen[3];    // Matriz de coordenadas en la pantalla
    GLfloat Color[4];     // Matriz con los colores
    struct Node *next;    // Puntero hacia el nodo a la derecha  
    struct Node *inf;     // Punerto hacia el nodo debajo de este
  };
\end{lstlisting}
\subsubsection{Tipos de nodos}
Básicamente podemos distinguir entre los diferentes tipos de nodos dependiendo de como deben de ser interpretados.
\begin{itemize}
\item{\textbf{Inicio} : es el primer nodo, no tiene ninguna información excepto que señala al primer nodo con información útil.}
\item{\textbf{Encabezado} : en el tipo contiene la forma en la que se tienen que unir los vértices que se encuentran debajo de este nodo, a la derecha tiene otro encabezado o nada si es el último encabezado.}
  \item{\textbf{Vértice} : contiene información sobre las coordenadas reales, proyectadas y en la pantalla, además del color. Debajo tiene otro vértice excepto en caso de ser el último vértice de esa estructura.}
\end{itemize}

\subsection{Organización de la información dentro de las matrices del nodo}
En el nodo de un vértice se puede encontrar la información del mismo en las siguientes matrices.
\begin{figure}[ht]
  \centering
  \begin{bmatrix}
    x_{real} \\
    y_{real} \\
    z_{real}  \\
    1
  \end{bmatrix}
  \begin{bmatrix}
    x_{proyectada} \\
    y_{proyectada} \\
    z_{proyectada} \\
    1
  \end{bmatrix}
  \begin{bmatrix}
    x_{pantalla} \\
    y_{pantalla} \\
    1
  \end{bmatrix}
  \begin{bmatrix}
    color_r \\
    color_g \\
    color_b \\
    color_a
  \end{bmatrix}
  \caption{Matriz de las coordenadas reales, las coordenads proyectadas, las coordenadas en la pantalla y el color.}
\end{figure}


\subsection{Sintaxis de la gestión de vértices}
Para ir creando vértices se tiene que estructurar el código de forma similar a este ejemplo.
\begin{lstlisting}[language=C]
  glColor3f(0.0f, 0.0f, 0.0f);
  glBegin(GL_QUADS);
  glVertex3f(0.75f, 0.75f);
  glVertex3f(0.75f, -0.75f);
  glVertex3f(-0.75f, -0.75f);
  glVertex3f(-0.75f, 0.75f);
  glEnd();
\end{lstlisting}
Se explicará el funcionamiento de esas funciones en las siguientes subsecciones.
\subsection{Colores en los vértices}
Utilizando la función
\begin{lstlisting}[language=C]
  glColor3f(Glclampf red, GLclampf green, GLclampf blue)
\end{lstlisting}
se puede asignar un color a todos los vértices que se definan posteriormente hasta que se vuelva a llamar una función de color.
\subsection{Sistemas de unión de vértices}
Para notificar al programa de que queremos una nueva estructura gráfica llamamos a la función
\begin{lstlisting}[language=C]
  glBegin(GLEnum mode)
\end{lstlisting}
Y como único argumento introducimos el modo de dibujo que queremos utilizar. Los distintos modos que se ofrecen son los siguientes.
\subsubsection{GL\_QUAD}
El número de vértices para el uso correcto debe de ser divisor de 4. Se ejecutarán los siguientes pasos.
\begin{itemize}
  \item{Línea del vértice 0 al vértice 1}
  \item{Línea del vértice 1 al vértice 2}
  \item{Línea del vértice 2 al vértice 3}
  \item{Línea del vértice 3 al vértice 0}
    \item{Se tomarán los siguientes cuatro vértices en caso de que existan y se reinicia el proceso}
\end{itemize}
\subsection{Creación de vértices}
Existen diversas funciones para crear vertices, dependiendo de si quieren utilizar numeros flotantes o enteros, y si se quieren utilizar tres dimensiones o solo dos. Esas funciones son las siguientes.
\begin{lstlisting}[language=C]
  glVertex2f(GLfloat x, GLfloat y);
  glVertex2i(GLint x, GLint y);
  glVertex3f(GLfloat x, GLfloat y, GLfloat z);
  glVertex3i(GLint x, GLint y, GLint z);
\end{lstlisting}
\subsection{Finalizacion de la estructura grafica}
Una vez que se han terminado de introducir los vertices, hace falta llamar a la siguiente funcion sin ningun argumento.
\begin{lstlisting}[language=C]
  glEnd();
\end{lstlisting}
\section{Conversiones de coordenadas}
\subsection{Conversión de coorenadas normalizadas a coordenadas en la pantalla}
Una vez se tienen las coordenadas de los puntos entre las coordenadas (-1, -1) y (1, 1) se busca encontrar la coordenada correspondiente en la pantalla.
\begin{itemize}
  \item{\(x_d\) es la coordenada en la pantalla}
  \item{\(x_s\) es la coordenada real normalizada}  
  \item{\(x_m\) es la coordenada donde comienza la superfície en la que queremos dibujar}
  \item{\(x_M\) es la coordenada donde termina la superfície en la que queremos dibujar}  
  \item{\(\Delta x = x_M - x_m\)}
\end{itemize}
\begin{equation}
  \frac{x_s-(-1)}{1-(-1)} = \frac{x_d - x_m}{\Delta x}
\end{equation}
Si aislamos \(x_d\) obtenemos la siguiente ecuación:
\begin{equation}
  x_d = \frac{\Delta x \cdot x_s}{2}+\frac{\Delta x}{2}+x_m
\end{equation}
En el caso de la coordenada \(y\) funciona igual excepto que cambiamos el sentido así que tiene una pequeña variación.
\begin{equation}
  y_d = \frac{-(\Delta y) \cdot y_s}{2}+\frac{\Delta y}{2}+y_m
\end{equation}
Y en forma de matriz, la operación quedaría así.
\\
\begin{equation}
  \begin{bmatrix}
     \(\frac{\Delta x}{2}\) && 0 && \(\frac{\Delta x}{2} + x_m\)\\
     0 && \(- \frac{\Delta y}{2} && \(\frac{\Delta y}{2} + y_m$\) \\
     0 && 0 && 1
  \end{bmatrix}
  \cdot
  \begin{bmatrix}
    \(x_s\)\\
    \(y_s\)\\
    \(1\)
  \end{bmatrix}
  =
  \begin{bmatrix}
    \(x_d\)\\
    \(y_d\)\\
    \(1\)
  \end{bmatrix}
\end{equation}
    
  
\newpage
\chapter{Teoría e implementación de el motor gráfico}
Este capítulo está dedicado a observar desde un punto de vista primero teórico y luego práctico el uso de la librería gráfica una vez aplicado en un motor gráfico.
\newpage
\chapter{Situación actual}
En este capítulo mi objetivo es recopilar información extraída de individuos familiarizados con el desarrollo de software pero por motivos diferentes y intentar exponer su opinión en el software hecho a mano.
\newpage
\chapter{Valoración general y conclusión}
Finalmente, utilizando las nociones aprendidas en el transcurso de este Treball de Recerca intentaré llegar a una conclusión y ver si la hipótesis presentada realmente se sostiene tras finalizar el trabajo.
\end{document}

